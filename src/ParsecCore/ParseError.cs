using ParsecCore.Help;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ParsecCore
{

    public interface IParseErrorVisitor<T, A>
    {
        T Visit(StandardError error, A arg);
        T Visit(CustomError error, A arg);
    }

    /// <summary>
    /// Represents an error which occured during parsing
    /// </summary>
    public abstract partial class ParseError : IParseErrorVisitor<ParseError, None>
    {
        public abstract Position Position { get; set; }

        public abstract T Accept<T, A>(IParseErrorVisitor<T, A> visitor, A arg);

        // ParseError is its own visitor used for merging two ParseErrors together
        public abstract ParseError Visit(StandardError error, None _);
        public abstract ParseError Visit(CustomError error, None _);

        public static ParseError? CombineErrors(ParseError? left, ParseError? right)
        {
            if (left is null && right is null) return null;
            if (left is null) return right;
            if (right is null) return left;
            if (left.Position > right.Position) return left;
            if (left.Position < right.Position) return right;
            return left.Accept(right, None.Instance);
        }
    }

    /// <summary>
    /// Standard error generated by the parser itself during parsing.
    /// </summary>
    public sealed class StandardError : ParseError
    {
        public StandardError(Position position, Maybe<ErrorItem> unexpected, IEnumerable<ErrorItem> expected)
        {
            _position = position;
            Unexpected = unexpected;
            Expected = expected;
        }

        public StandardError(Position position, Maybe<ErrorItem> unexpected, ErrorItem expected)
            : this(position, unexpected, expected.ToEnumerable())
        {
        }

        public override Position Position { get => _position; set => _position = value; }

        public override T Accept<T, A>(IParseErrorVisitor<T, A> other, A arg)
        {
            return other.Visit(this, arg);
        }

        public override string ToString()
        {
            StringBuilder builder = new();
            builder.AppendLine($"({Position}):");
            bool anyExpected = Expected.Any();
            if (Unexpected.IsEmpty && !anyExpected)
            {
                return builder.AppendLine("  Unknown parsing error").ToString();
            }

            builder.Append(Unexpected.Match(
                just: item => $"  encountered: {item.ToString()}\n",
                nothing: () => string.Empty
            ));

            if (!anyExpected)
            {
                return builder.ToString();
            }

            foreach (var item in Expected)
            {
                builder.AppendLine($"     expected: {item.ToString()}");
            }

            return builder.ToString();
        }

        public override ParseError Visit(StandardError error, None _)
        {
            return new StandardError(
                Position,
                CombineUnexpected(Unexpected, error.Unexpected),
                Expected.Union(error.Expected)
            );
        }
        public override ParseError Visit(CustomError error, None _)
        {
            return error; // prefer custom error over our standard error
        }

        /// <summary>
        /// We only merge unexpected errors in case both errors occurred at the same position. Therefore we choose
        /// the one which is more specific (exists or contains a longer prefix of the input)
        /// </summary>
        /// <param name="left"> One of the unexpected errors </param>
        /// <param name="right"> One of the unexpected errors </param>
        /// <returns> The unexpected error which is more specific </returns>
        private static Maybe<ErrorItem> CombineUnexpected(Maybe<ErrorItem> left, Maybe<ErrorItem> right)
        {
            if (left.IsEmpty)
            {
                return right;
            }

            if (right.IsEmpty)
            {
                return left;
            }

            return left.Value.Size >= right.Value.Size ? left : right;
        }

        private Position _position;
        public Maybe<ErrorItem> Unexpected { get; init; }
        public IEnumerable<ErrorItem> Expected { get; init; }
    }

    /// <summary>
    /// Custom error specified by the user.
    /// </summary>
    public sealed class CustomError : ParseError
    {
        public CustomError(Position position, IEnumerable<CustomErrorItem> customErrors)
        {
            _position = position;
            Customs = customErrors;
        }

        public CustomError(Position position, CustomErrorItem error) : this(position, error.ToEnumerable())
        {
        }

        public override Position Position { get => _position; set => _position = value; }

        public override T Accept<T, A>(IParseErrorVisitor<T, A> other, A arg)
        {
            return other.Visit(this, arg);
        }

        public override string ToString()
        {
            if (!Customs.Any())
            {
                return $"({Position}):\n  Unknown custom parsing error";
            }

            return $"({Position}):\n  " + string.Join("\n  ", Customs);
        }

        public override ParseError Visit(StandardError error, None _)
        {
            return this; // prefer our custom error over standard error
        }
        public override ParseError Visit(CustomError error, None _)
        {
            return new CustomError(Position, Customs.Union(error.Customs));
        }

        private Position _position;
        public IEnumerable<CustomErrorItem> Customs { get; init; }
    }
}
